1 请区分列表的获取切片和切片赋值：前者获取到一个新的对象（浅拷贝），而后者是对原列表的修改！
  ndarray相比列表，在此表现出了不同的特性：无论是获取切片还是切片赋值，ndarray都不会创建新的对象，而是共享原数据。
2 使用*n的方式初始化对象，只会得到同一个对象的多个引用；要初始化多个不同对象，请使用for循环或列表推导等操作。
3 列表推到和生成表达式形式上类似，前者最外层是中括号，后者是圆括号；前者生成一个列表，而后者生成一个迭代器。
4 相比于继承dict，继承UserDict通常是更合适的方案。原因是：
  继承自dict的子类，某些方法的覆写是无效的，这些方法是由非pyhton语言在底层实现的(比如get方法不会调用覆写的__getitem__)。
  而UserDict的所有方法都是在python层面实现的，因此可以被有效的覆写，只是有一个用来实现dict功能的dict成员而已。
5 不能在遍历字典的同时添加元素。因为添加元素可能会导致字典散列表的扩容————这会导致原来的数据的存储位置发生变化，从而使得遍历操作无法完整遍历所有数据。
6 默认情况下，如果两个变量或对象相等，即“变量1==变量2”，那么它们的哈希值也应该是相等的，这能防止字典的key发生不必要的混淆。这个规则对覆写提出了要求：
  如果覆写了某类的__eq__方法，那么最好也覆写它的__hash__方法，反之亦然，保证“变量1==变量2”和“变量1的哈希值等于变量2的哈希值”始终等价。
7 str有个特殊的特性：s[n] == s[n:n+1]。绝大多数可切片的类都不会满足这个等式，包括list、bytearray等等。
8 python3中函数的参数可以分为positional参数和keyword-only参数。后者在使用时，必须用“key=value”的方式传入函数。而且，无论是定义时还是使用时，
  keyword-only参数都必须跟在positional参数之后。如果定义函数时，需要传入keyword-only参数，而且函数没有*args或**args这样的不定长参数，
  那么使用如下格式分隔positional参数和keyword-only参数：def 函数名（positional参数，*，keyword-only参数）
9 有些代码会在引入（import）时就运行，比如注解中的代码。
10 global声明使函数能使用全局变量，而nonlocal声明使嵌套在内部的函数能使用外部函数定义的局部变量。

