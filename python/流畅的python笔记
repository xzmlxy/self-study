1 请区分列表的获取切片和切片赋值：前者获取到一个新的对象（浅拷贝），而后者是对原列表的修改！
  ndarray相比列表，在此表现出了不同的特性：无论是获取切片还是切片赋值，ndarray都不会创建新的对象，而是共享原数据。
2 使用*n的方式初始化对象，只会得到同一个对象的多个引用；要初始化多个不同对象，请使用for循环或列表推导等操作。
3 列表推到和生成表达式形式上类似，前者最外层是中括号，后者是圆括号；前者生成一个列表，而后者生成一个迭代器。
4 相比于继承dict，继承UserDict通常是更合适的方案。原因是：
  继承自dict的子类，某些方法的覆写是无效的，这些方法是由非pyhton语言在底层实现的(比如get方法不会调用覆写的__getitem__)。
  而UserDict的所有方法都是在python层面实现的，因此可以被有效的覆写，只是有一个用来实现dict功能的dict成员而已。
5 不能在遍历字典的同时添加元素。因为添加元素可能会导致字典散列表的扩容————这会导致原来的数据的存储位置发生变化，从而使得遍历操作无法完整遍历所有数据。
6 默认情况下，如果两个变量或对象相等，即“变量1==变量2”，那么它们的哈希值也应该是相等的，这能防止字典的key发生不必要的混淆。这个规则对覆写提出了要求：
  如果覆写了某类的__eq__方法，那么最好也覆写它的__hash__方法，反之亦然，保证“变量1==变量2”和“变量1的哈希值等于变量2的哈希值”始终等价。
7 str有个特殊的特性：s[n] == s[n:n+1]。绝大多数可切片的类都不会满足这个等式，包括list、bytearray等等。
8 python3中函数的参数可以分为positional参数和keyword-only参数。后者在使用时，必须用“key=value”的方式传入函数。而且，无论是定义时还是使用时，
  keyword-only参数都必须跟在positional参数之后。如果定义函数时，需要传入keyword-only参数，而且函数没有*args或**args这样的不定长参数，
  那么使用如下格式分隔positional参数和keyword-only参数：def 函数名（positional参数，*，keyword-only参数）
9 有些代码会在引入（import）时就运行，比如注解中的非闭包函数代码。这也是闭包的意义，将函数的运行延迟到执行时。
  不过使用闭包函数装饰原函数时，会修改原函数的某些属性，比如__name__等。在此对闭包函数使用@functools.wraps(原函数名)注解，可以方便的解决该问题。
10 global声明使函数能使用全局变量，而nonlocal声明使嵌套在内部的函数能使用外部函数定义的局部变量。
11 如果一个函数经常被调用，且常常需要返回相同的值，那么可以加上@functools.lru_cache()注解作为优化。
12 python使用"with"关键字管理上下文。当使用该关键字时，会调用上下文对象的__enter__方法；而当上下文相关的语句结束后，会调用上下文对象的__exit__方法。
   这么做的作用，本质上是简化了和上下文对象相关的try···finally···结构。把finally中需要执行的对象语句，写入对象的__exit__方法方法即可。

