1 请区分列表的获取切片和切片赋值：前者获取到一个新的对象（浅拷贝），而后者是对原列表的修改！
  ndarray相比列表，在此表现出了不同的特性：无论是获取切片还是切片赋值，ndarray都不会创建新的对象，而是共享原数据。
2 使用*n的方式初始化对象，只会得到同一个对象的多个引用；要初始化多个不同对象，请使用for循环或列表推导等操作。
3 列表推到和生成表达式形式上类似，前者最外层是中括号，后者是圆括号；前者生成一个列表，而后者生成一个迭代器。
4 相比于继承dict，继承UserDict通常是更合适的方案。原因是：
  继承自dict的子类，某些方法的覆写是无效的，这些方法是由非pyhton语言在底层实现的(比如get方法不会调用覆写的__getitem__)。
  而UserDict的所有方法都是在python层面实现的，因此可以被有效的覆写，只是有一个用来实现dict功能的dict成员而已。
5 不能在遍历字典的同时添加元素。因为添加元素可能会导致字典散列表的扩容————这会导致原来的数据的存储位置发生变化，从而使得遍历操作无法完整遍历所有数据。
6 默认情况下，如果两个变量或对象相等，即“变量1==变量2”，那么它们的哈希值也应该是相等的，这能防止字典的key发生不必要的混淆。这个规则对覆写提出了要求：
  如果覆写了某类的__eq__方法，那么最好也覆写它的__hash__方法，反之亦然，保证“变量1==变量2”和“变量1的哈希值等于变量2的哈希值”始终等价。
7 str有个特殊的特性：s[n] == s[n:n+1]。绝大多数可切片的类都不会满足这个等式，包括list、bytearray等等。
8 python3中函数的参数可以分为positional参数和keyword-only参数。后者在使用时，必须用“key=value”的方式传入函数。而且，无论是定义时还是使用时，
  keyword-only参数都必须跟在positional参数之后。如果定义函数时，需要传入keyword-only参数，而且函数没有*args或**args这样的不定长参数，
  那么使用如下格式分隔positional参数和keyword-only参数：def 函数名（positional参数，*，keyword-only参数）
9 调用函数时，没有设置默认值的positional参数是必须传入的。在设置默认值时，需要注意：把函数参数的默认值设为一个可变对象是一件危险的事情。
   因为所有函数对象会使用默认值指向的同一个对象，仅仅是多个引用而已！
10 关于装饰器：
  （1）有些代码会在引入（import）时就运行，比如装饰器中的非内嵌函数代码。
  （2）使用闭包函数装饰原函数时，会修改原函数的某些属性，比如__name__等。在此，对闭包函数使用@functools.wraps(原函数名)，可以方便的解决该问题。
  （3）为了实现装饰器，使用类比使用函数更合适，需要覆写类的__call__方法。
11 global声明使函数能使用全局变量，而nonlocal声明使嵌套在内部的函数能使用外部函数定义的局部变量。
12 如果一个函数经常被调用，且常常需要返回相同的值，那么可以加上@functools.lru_cache()作为优化。
13 python使用"with"关键字管理上下文。当使用该关键字时，会调用上下文对象的__enter__方法；而当上下文相关的语句结束后，会调用上下文对象的__exit__方法。
   这么做的作用，本质上是简化了和上下文对象相关的try···finally···结构。把finally中需要执行的对象语句，写入对象的__exit__方法即可。
14 del不删除对象，只是删除对象的引用。
15 当print对象时，首先查找对象是否存在__str__方法，如果存在则调用__str__，否则调用__repr__。由于__repr__方法在object中就已定义，所以它是必然存在的。
16 当使用“对象名.属性名=值”这样的语句为对象的属性赋值时，首先会去查找对象是否存在同名的属性，如果不存在则调用__setattr__，如果依然找不到，
   则会为对象新建一个属性并赋值，这就是Python对象的动态绑定属性。Python甚至还能动态绑定方法，虽然这不太常用。
   如果希望禁止对象动态绑定属性，那么可以在__setattr__方法中直接抛出异常，防止为对象新建属性。
   当获取对象的属性值时，流程也是差不多的：查找属性 （如果找不到）--> 调用__getattr__ (如果找不到)--> 抛出异常。
17 另外，使用__slot__也可以达到禁止对象动态绑定属性的目的，在类中添加：__slot__（属性1，属性2，···）。
   声明后，类对象便不能拥有任何非__slot__属性，也就无法动态绑定属性了。并且__slot__能优化内存的使用，减少占用的空间。
   但是————出于“禁止对象动态绑定属性”的目的使用__slot__，是不被推荐的。因为它会带来一些使用上的不便，比如它无法被继承等等。
   所以，除非有优化内存使用的必要，否则应谨慎使用__slot__。

