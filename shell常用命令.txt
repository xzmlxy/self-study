基本命令：
cp(拷贝命令) -r（若拷贝文件夹，则拷贝文件夹下的所有文件）
rm(删除命令) -r(可删除目录)
cat(放入内存展示)  指定文件
sudo chmod -R 777 文件名（获取执行权限）
gzip –c filename > filename.gz （压缩文件）

Linux三剑客：
(1)grep(常用于在文本中查找)，一般格式如下：gred 查找的字符串或正则式 文件名或目录名。
(2)sed(常用于文本的编辑：替换、插入等)。举例替换命令如下：sed ‘s/oldstring/newstring/标志位参数（用于满足不同的替换场景）’ filename。
注意：默认sed不会修改源文件，也不会保存修改结果，如有需要，需用“>”重定向。
(3)awk(常用于文本的分析、对比等，功能最为强大)，一般格式如下：awk ‘BEGIN{……} condition{commands……} END{……}’ filename。
默认情况下的commond为print $0（打印整行）；另外可添加condition{commands}块。

VIM使用：
vim 文件名（进入vim打开文件）
在进入vim后默认为命令状态，按“:”自动跳至文末。此时可输入各种命令，如“q!”(不保存退出)、“wq”（保存退出）等等。
在命令状态下无法编辑文本，按“a”即可进入编辑模式，编辑完成后按ESC返回命令状态。

默认情况下，shell每调用一个子shell，都会导致重开一个shell进程，子shell会继承父shell的环境变量，但不会影响父shell的环境变量。
如果希望子shell和父shell在同一个进程中运行，可使用source（或exec）运行子shell。

和python和Java不同，shell的运算符间不能添加空格！！另外，需要把运算式放在$((...))中才能正常运算得到结果，否则得到的是算式的字符串

当执行shell脚本时，可传入两种不同类型的参数：
一种是option，类似关键字参数，它是已在sh内部声明的全局变量，在传参时需要指定参数名(“--参数名 参数值”)；
另外一种是arg，类似位置参数，它在sh内部未被申明，传参时直接传入即可，通过“$”使用。




class MainTransformer(BaseEstimator, TransformerMixin):

    def __init__(self, convert_cyclical: bool = False, create_interactions: bool = False, n_interactions: int = 20):
        """
        Main transformer for the data. Can be used for processing on the whole data.

        :param convert_cyclical: convert cyclical features into continuous
        :param create_interactions: create interactions between features
        """

        self.convert_cyclical = convert_cyclical
        self.create_interactions = create_interactions
        self.feats_for_interaction = None
        self.n_interactions = n_interactions

    def fit(self, X, y=None):

        if self.create_interactions:
            self.feats_for_interaction = [col for col in X.columns if 'sum' in col
                                          or 'mean' in col or 'max' in col or 'std' in col
                                          or 'attempt' in col]
            self.feats_for_interaction1 = np.random.choice(self.feats_for_interaction, self.n_interactions)
            self.feats_for_interaction2 = np.random.choice(self.feats_for_interaction, self.n_interactions)

        return self

    def transform(self, X, y=None):
        data = copy.deepcopy(X)
        if self.create_interactions:
            for col1 in self.feats_for_interaction1:
                for col2 in self.feats_for_interaction2:
                    data[f'{col1}_int_{col2}'] = data[col1] * data[col2]

        if self.convert_cyclical:
            data['timestampHour'] = np.sin(2 * np.pi * data['timestampHour'] / 23.0)
            data['timestampMonth'] = np.sin(2 * np.pi * data['timestampMonth'] / 23.0)
            data['timestampWeek'] = np.sin(2 * np.pi * data['timestampWeek'] / 23.0)
            data['timestampMinute'] = np.sin(2 * np.pi * data['timestampMinute'] / 23.0)

#         data['installation_session_count'] = data.groupby(['installation_id'])['Clip'].transform('count')
#         data['installation_duration_mean'] = data.groupby(['installation_id'])['duration_mean'].transform('mean')
#         data['installation_title_nunique'] = data.groupby(['installation_id'])['session_title'].transform('nunique')

#         data['sum_event_code_count'] = data[['2000', '3010', '3110', '4070', '4090', '4030', '4035', '4021', '4020', '4010', '2080', '2083', '2040', '2020', '2030', '3021', '3121', '2050', '3020', '3120', '2060', '2070', '4031', '4025', '5000', '5010', '2081', '2025', '4022', '2035', '4040', '4100', '2010', '4110', '4045', '4095', '4220', '2075', '4230', '4235', '4080', '4050']].sum(axis=1)

        # data['installation_event_code_count_mean'] = data.groupby(['installation_id'])['sum_event_code_count'].transform('mean')

        return data

    def fit_transform(self, X, y=None, **fit_params):
        data = copy.deepcopy(X)
        self.fit(data)
        return self.transform(data)
