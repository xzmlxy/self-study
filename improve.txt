import pandas as pd
from code.models.XGBModel import XGBModel
from code.models.LightGBModel import LightGBModel
from code.models.CatBModel import CatBModel
from code.models.StackingModel import StackingModel
from sklearn.metrics import cohen_kappa_score
from code.DataUtil import DataUtil


class ModelAgent:
    def __init__(self, data_x, data_y, one_model=False):
        self.model_dic = {}
        self.one_model = one_model
        self.cat_features = []
        for name in data_x.columns.values:
            if name.startswith('world_name'):
                self.cat_features.append(name)
        if not one_model:
            assessments = data_x['title'].unique()
            for assessment in assessments:
                train_x = data_x[data_x['title'] == assessment]
                train_y = data_y[data_y['game_session'].isin(train_x['game_session'])]
                combine_x_y = pd.merge(train_x, train_y, on='game_session')
                self.model_dic[assessment] = self.create_model(combine_x_y)
        else:
            for name in DataUtil.assessment_names:
                self.cat_features.append('title_name_' + name)
            data_x['title_name'] = data_x['title']
            data_x = pd.get_dummies(data_x, columns=['title_name'])
            combine_x_y = pd.merge(data_x, data_y, on='game_session')
            self.model_dic['all'] = self.create_model(combine_x_y)

    def create_model(self, data):
        data.drop(columns=['installation_id', 'title', 'game_session'], inplace=True)
        XGBM = XGBModel(data, y_name='accuracy_group')
        LGBM = LightGBModel(data, y_name='accuracy_group')
        CBM = CatBModel(data, y_name='accuracy_group')
        CBM.set_cat_features(self.cat_features)
        stacking_model = StackingModel([XGBM, LGBM, CBM])
        return LGBM

    def train(self):
        for _, model in self.model_dic.items():
            if model is not None:
                model.train()

    def adjust_model_params(self):
        for _, model in self.model_dic.items():
            if model is not None:
                model.adjust_params_one_by_one()

    def get_current_model_cv_cohen_kappa_score(self, cv):
        score_dict = {}
        for name, model in self.model_dic.items():
            if model is not None:
                value = model.get_cv_score(cv, cohen_kappa_score)
                score_dict[name] = value
        return score_dict

    def predict(self, test_data):
        if not self.one_model:
            all_results = []
            for assessment in self.model_dic:
                part_test_data = test_data[test_data['title'] == assessment]
                part_test_data.reset_index(drop=True)
                predict_result = self.model_dic[assessment].predict(
                    part_test_data.drop(columns=['installation_id', 'title', 'game_session']))
                if predict_result is not None:
                    result = pd.DataFrame(
                        {'installation_id': part_test_data['installation_id'].values, 'accuracy_group': predict_result})
                    all_results.append(result)
            return pd.concat(all_results)
        else:
            test_data['title_name'] = test_data['title']
            test_data = pd.get_dummies(test_data, columns=['title_name'])
            predict_result = self.model_dic['all'].predict(
                test_data.drop(columns=['installation_id', 'title', 'game_session']))
            return pd.DataFrame(
                {'installation_id': test_data['installation_id'].values, 'accuracy_group': predict_result})
                
                

