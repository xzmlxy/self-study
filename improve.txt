
import numpy as np
from sklearn.feature_selection import SelectFromModel
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import StratifiedKFold
from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
from abc import ABCMeta, abstractmethod


class BaseModel(metaclass=ABCMeta):
    def __init__(self, data, y_name: str = None, params: dict = None):
        self.data = shuffle(data).reset_index(drop=True)
        self.params = params
        self.threshold = 100
        self.model = None
        self.selection = None
        self.y_name = y_name
        if self.y_name is None:
            raise Exception()
        self.x_train, self.y_train = self.__split_x_y(self.data)

    def __split_x_y(self, data):
        x = data[[column_name for column_name in data.columns if column_name != self.y_name]]
        y = data[self.y_name]
        return x, y

    def set_select_feature_threshold(self, threshold):
        self.threshold = threshold

    def train(self):
        print('Training...')
        x_train, x_test, y_train, y_test = train_test_split(self.x_train, self.y_train, test_size=0.1, random_state=6)
        self.model, self.selection = self._internal_train(x_train, y_train, x_test, y_test)
        print('Finish to train.')

    def predict(self, data):
        if self.model is not None:
            if self.selection is not None:
                x_train = self.selection.transform(data)
            else:
                x_train = data
            return self.model.predict(x_train)
        else:
            print("No model to  predict!")
            return None

    def _internal_train(self, x_train, y_train, x_test, y_test, select=True):
        x_train = self.extra_pre_process(x_train)
        x_test = self.extra_pre_process(x_test)
        model = self._get_model(x_train, y_train, x_test, y_test)
        if select:
            thresholds = np.sort(model.feature_importances_)
            selection = SelectFromModel(model, threshold=thresholds[-self.threshold], prefit=True)
            x_train = selection.transform(x_train)
            if x_test is not None:
                x_test = selection.transform(x_test)
            model = self._get_model(x_train, y_train, x_test, y_test)
            return model, selection
        else:
            return model, None

    @abstractmethod
    def _get_model(self, x_train, y_train, x_test, y_test):
        return None

    def get_cv_score(self, cv, loss_fun):
        result = np.ndarray(cv)
        skf = StratifiedKFold(n_splits=cv)
        i = 0
        for train, test in skf.split(self.x_train, self.y_train):
            x_train = self.x_train.iloc[train]
            y_train = self.y_train.iloc[train]
            x_test = self.x_train.iloc[test]
            y_test = self.y_train.iloc[test]
            model, selection = self._internal_train(x_train, y_train, x_test, y_test, select=False)
            if selection is not None:
                select_x_train = selection.transform(x_test)
            else:
                select_x_train = x_test
            predict_y = model.predict(select_x_train)
            result[i] = loss_fun(predict_y, y_test)
            print(result[i])
            i += 1
        return result.mean()

    def adjust_params(self, one_by_one=True):
        params = self.create_adjust_params()
        if params is not None:
            self.train()
            if one_by_one:
                self._internal_adjust_params_one_by_one(params)
            else:
                self._internal_adjust_param(params)
            print(self.params)

    @abstractmethod
    def create_adjust_params(self) -> dict:
        return {}

    def _internal_adjust_params_one_by_one(self, params):
        for key, value_range in params.items():
            self._internal_adjust_param({key: value_range})

    def _internal_adjust_param(self, adjust_param):
        if self.model is None:
            print("No model to adjust!")
        else:
            my_cv = StratifiedKFold(n_splits=5)
            print('Adjusting...')
            gs = GridSearchCV(self.model, adjust_param, cv=my_cv)
            gs.fit(self.extra_pre_process(self.x_train), self.y_train)
            self.params.update(gs.best_params_)
            print('Finish to adjust.')
            print("参数的最佳取值：", gs.best_params_)

    def extra_pre_process(self, data):
        return data
