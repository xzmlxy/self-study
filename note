await能像yield from一样返回结果。
协程需要包装成Task,然后才能被asyncio的其他类执行，其中Task是Future的子类。
协程本质上是线程控制权的转移，不会引起线程的阻塞。因此在编写协程代码时，需要警惕所使用的类和库会不会引起线程阻塞。比如asyncio.sleep()只会返回一个什么都不做的协程，而time.sleep()会阻塞线程；requests库在请求接口时会阻塞协程，而aiohttp则不会等等。
协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方（线程调度时候寄存器上下文及栈等保存在内存中），在切回来的时候，再恢复先前保存的寄存器上下文和栈。
可以以这样的方式阅读使用协程的代码：忽略掉await关键字，这时候的代码常常就是事件的流程代码。然后在会发生等待的语句前加上await——给出控制权，以实现异步调用，这时候就变成使用协程的代码了。
在编写网络接口的代码时，有时候会碰到这样的情况：需要同步的调用接口。要根据前一个接口的返回结果，来调用下一个接口。这就需要在前一个接口的回调函数中，完整的编写下一个接口的调用、回调等。类似这样的过多层的函数嵌套，称为“回调地狱”。
事件驱动模型，它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。
对于完全同时可获取控制权的协程，可能是按照某个伪随机过程来决定先执行谁，而不是抢占。
2839450617
