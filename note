
   
   不同world、不同type、不同title的总占用时长，总点击数；以及同一world的Assessment的正确/错误次数、不同得分次数
   

   


    @staticmethod
    def create_session_features(data_file):
        if 'train' in data_file:
            data = DataUtil.get_data_from_raw_file(DataUtil.train_data)
        else:
            data = DataUtil.get_data_from_raw_file(DataUtil.test_data)
        all_session = data['game_session'].unique()
        length = len(all_session)
        print(length)
        session_features_dic = {'title': [0] * length, 'type': [0] * length, 'world': [0] * length}
        for column in DataUtil.columns_list:
            session_features_dic[column] = [0] * length
        for code in DataUtil.event_code_list:
            session_features_dic[code] = [0] * length
        for event_id in DataUtil.correct_event_id:
            session_features_dic[event_id + "_correct"] = [0] * length
            session_features_dic[event_id + "_incorrect"] = [0] * length
        for event_id in DataUtil.misses_event_id:
            session_features_dic[event_id + "_misses"] = [0] * length
        id_groups_data = data.groupby(['installation_id'], as_index=False)
        session_count = -1
        for _, id_data in id_groups_data:
            game_session = None
            start_row = -1
            event_id_count_dic = {}
            id_data = id_data.reset_index(drop=True)
            for i, row in id_data.iterrows():
                if row['game_session'] != game_session:
                    if game_session is not None:
                        session_count += 1
                        DataUtil.__get_feature_one_session(id_data[start_row:i], session_features_dic, session_count,
                                                           event_id_count_dic)
                    game_session = row['game_session']
                    start_row = i
                    event_id_count_dic.clear()
                DataUtil.__update_event_data(row, event_id_count_dic)
            session_count += 1
            DataUtil.__get_feature_one_session(id_data[start_row:], session_features_dic, session_count,
                                               event_id_count_dic)
        df = pd.DataFrame(session_features_dic)
        df = pd.get_dummies(df, columns=['title', 'type', 'world'])
        df.to_csv(os.path.join(DataUtil.create_path, 'session_' + data_file), index=False)
        return df

    @staticmethod
    def __get_feature_one_session(session_data, session_features_dic, count, event_id_dic):
        session_features_dic['installation_id'][count] = session_data['installation_id'].iloc[0]
        session_features_dic['game_session'][count] = session_data['game_session'].iloc[0]
        session_features_dic['type'][count] = session_data['type'].iloc[0]
        session_features_dic['title'][count] = session_data['title'].iloc[0]
        session_features_dic['world'][count] = session_data['world'].iloc[0]
        session_features_dic['event_count'][count] = len(session_data)
        DataUtil.__get_time_data(session_data['timestamp'], session_features_dic, count)
        DataUtil.__get_code_data(session_data, session_features_dic, count)
        DataUtil.__get_event_data(session_features_dic, event_id_dic, count)

    @staticmethod
    def __get_time_data(times, session_dic, count):
        date = pd.to_datetime(times.iloc[0])
        session_dic['month'][count] = date.month
        session_dic['day'][count] = date.day
        session_dic['hour'][count] = date.hour
        session_dic['weekday'][count] = date.weekday()
        if date.weekday() > 4:
            session_dic['isWeekend'][count] = 1
        else:
            session_dic['isWeekend'][count] = 0
        if len(times) > 1:
            end_date = pd.to_datetime(times.iloc[-1])
            session_dic['total_duration'][count] = int((end_date - date).total_seconds())
        else:
            session_dic['total_duration'][count] = 0

    @staticmethod
    def __get_code_data(df_data, session_dic, count):
        code_series = df_data['event_code'].value_counts()
        for code in DataUtil.event_code_list:
            if code in code_series:
                session_dic[code][count] = code_series[code]

    @staticmethod
    def __get_event_data(session_dic, event_id_dic, count):
        for key, value in event_id_dic.items():
            session_dic[key][count] = value

    @staticmethod
    def __update_event_data(row, event_id_dic):
        if row['event_id'] in DataUtil.misses_event_id:
            target_arg = 'misses'
        elif row['event_id'] in DataUtil.correct_event_id:
            target_arg = 'correct'
        else:
            target_arg = None
        if target_arg is not None:
            args = json.loads(row['event_data'])
            target = args[target_arg]
            if target_arg == 'misses':
                key = row['event_id'] + '_misses'
                value = target
            else:
                value = 1
                if target:
                    key = row['event_id'] + '_correct'
                else:
                    key = row['event_id'] + '_incorrect'
            if key not in event_id_dic:
                event_id_dic[key] = 0
            event_id_dic[key] += value

    @staticmethod
    def create_data_for_model():
        all_predict_assessment, label_data = DataUtil.__pre_process_train_label_data()
        all_train_assessment = label_data['game_session'].unique()
        train_data = []
        test_data = []
        train_label_data = []
        for file_path in [DataUtil.session_train_data, DataUtil.session_test_data]:
            all_path = os.path.join(DataUtil.create_path, file_path)
            if os.path.exists(all_path):
                df = DataUtil.get_data_from_file(all_path)
            else:
                df = DataUtil.create_session_features(all_path)
            groups = df.groupby(['installation_id'])
            for installation_id, data in groups:
                data = data.reset_index(drop=True)
                accumulate_start_line = 0
                last_assessment_row = None
                for i, row in data.iterrows():
                    if row['Assessment'] == 1:
                        if row['game_session'] in all_train_assessment or row['game_session'] in all_predict_assessment:
                            accumulate_data = data[accumulate_start_line: i + 1]
                            if last_assessment_row is None:
                                label_key = label_data.keys()
                                value = [0] * len(label_key)
                                accumulate_label = pd.Series(dict(zip(label_key, value)))
                            else:
                                accumulate_label = last_assessment_row
                            if row['game_session'] in all_train_assessment:
                                DataUtil.__create_assessment_data(accumulate_data, accumulate_label,
                                                                  last_assessment_row, train_data)
                                train_label_data.append(row['game_session', 'accuracy_group'])
                            else:
                                DataUtil.__create_assessment_data(accumulate_data, accumulate_label,
                                                                  last_assessment_row, test_data)
                            accumulate_start_line = i
                            last_assessment_row = row
        return pd.DataFrame(train_data), train_label_data, pd.DataFrame(test_data)

    @staticmethod
    def __pre_process_train_label_data():
        label_train_data = DataUtil.get_data_from_raw_file(DataUtil.train_labels_data).drop(columns=['accuracy'])
        label_test_data = DataUtil.__search_more_labels_in_test_data()
        label_data = pd.concat([label_train_data, label_test_data], sort=False).reset_index()
        length = label_data.shape[0]
        for title in DataUtil.assessment_list:
            label_data[title + '_num_correct'] = [0] * length
            label_data[title + '_num_incorrect'] = [0] * length
            label_data[title + '_accuracy_group'] = [0] * length
        for i in range(label_data.shape[0]):
            label_data.at[i, label_data.at[i, 'title'] + '_num_correct'] = label_data.at[i, 'num_correct']
            label_data.at[i, label_data.at[i, 'title'] + '_num_incorrect'] = label_data.at[i, 'num_incorrect']
            label_data.at[i, label_data.at[i, 'title'] + '_accuracy_group'] = label_data.at[i, 'accuracy_group']
        all_test_data = DataUtil.get_data_from_raw_file(DataUtil.test_data)
        need_predict_game_sessions = []
        for i, data in all_test_data.groupby(['installation_id'], as_index=False):
            need_predict_game_sessions.append(data['game_session'].iloc[-1])
        return need_predict_game_sessions, label_data.drop(
            columns=['num_correct', 'num_incorrect', 'installation_id', 'title'])

    @staticmethod
    def __create_assessment_data(accumulate_data, accumulate_label, last_assessment_session, data):
        print(accumulate_data.shape)
        new_data = accumulate_data.iloc[-1][DataUtil.columns_list]
        accumulate_data = accumulate_data.drop(columns=['accuracy_group'])
        accumulate = accumulate_data[:-1].sum()
        accumulate_label = accumulate_label.drop(columns=['acc'])
        accumulate = accumulate.append(accumulate_label, ignore_index=False)
        accumulate = accumulate.drop(labels=['index', 'game_session'])
        if last_assessment_session is not None:
            for name in accumulate.index:
                accumulate[name] += data[-1][name]
        data.append(new_data.append(accumulate, ignore_index=False))

    @staticmethod
    def split_data_by_assessment_name(all_train_x, all_train_y, all_test_x):
        all_data = {}
        for assessment in DataUtil.assessment_list:
            train_x = all_train_x[all_train_x[assessment] == 1]
            test_x = all_test_x[all_train_x[assessment] == 1]
            train_y = all_train_y[all_train_y['game_session'].isin(train_x['game_session'])]
            all_data[assessment] = (train_x, train_y, test_x)
        return all_data

    @staticmethod
    @annotation_time
    def test():
        DataUtil.create_session_features(DataUtil.test_data)
