从工作内容来看，并发可以分为密集型和等待型。前者的每个任务都有大量的不间断（或几乎不间断）的操作或计算，而后者的每个任务的操

作和计算都不多，但是会发生等待（即阻塞）。对于前者来说，只有真正的并发才能解决问题，每个工作使用一个CPU核，这需要多核CPU的支

持；对于后者来说，可以使用适当的调度机制实现表面上的伪并发——在一个工作阻塞时进行另一个工作，这样的工作单个CPU即可处理。
在处理并发问题上，不同版本的Python编译器有不同的特性。最常用的Cpython有GIL锁（不过Jython编译器就没有这个锁），致使一个进程内

的线程无法使用多个CPU核，所以在处理密集型并发任务时，需要使用多进程；而处理等待型并发任务时，使用线程即可。不过，线程的调度

机制是抢占式的，如果各个任务之间可以协同工作，而不需要相互抢占，那么可以进一步省去抢占带来的性能损耗。因此，协程的概念便诞生了。

Python中的协程，广义来说是一个基于yield和相关关键字的生成器函数所返回的生成器对象；狭义来说是使用async关键字声明的函数（简称为协程函数）所返回的协程对象——它们都不会返回return关键字之后的东西。之所以它们都叫做协程，是因为在框架代码中，后者是基于前者实现的。也就是说，底层基于生成器，实现了可协作任务的协作式调度。
有一些关键字是专供协程函数使用的，非协程函数内部不可使用：await用来将当前程序流委托给子协程运行，当子协程运行完毕后，再返回

并进行下一步操作；async with用来在协程内部持有一个对象的上下文；async for用来从一个async生成器中读取内容（在生成器函数前添加

async关键字，返回的就是一个async生成器，它只能通过async for来读取内容，所以只能在协程函数内部使用）。
